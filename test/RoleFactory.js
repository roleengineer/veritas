// Here's how we would access our contract:
var abi = /* abi generated by the compiler */
var RoleFactoryContract = web3.eth.contract(abi)
var contractAddress = /* our contract address on Ethereum after deploying */
var RoleFactory = RoleFactoryContract.at(contractAddress)
// `RoleFactory` has access to our contract's public functions and events

// some sort of event listener to take the text input:
$("#ourButton").click(function(e) {
  var name = $("#nameInput").val()
  // Call our contract's `createRandomRole` function:
  RoleFactory.createRandomRole(name)
})

// Listen for the `NewRole` event, and update the UI
var event = RoleFactory.NewRole(function(error, result) {
  if (error) return
  generateRole(result.id, result.name, result.skill)
})

// take the Role skill, and update our image
function generateRole(id, name, skill) {
  let skillStr = String(skill)
  // pad SKILL with leading zeroes if it's less than 16 characters
  while (skillStr.length < 16)
    skillStr = "0" + skillStr

  let rolesDetails = {
    // first 2 digits make up the head. We have 7 possible heads, so % 7
    // to get a number 0 - 6, then add 1 to make it 1 - 7. Then we have 7
    // image files named "head1.png" through "head7.png" we load based on
    // this number:
    headChoice: skillStr.substring(0, 2) % 7 + 1,
    // 2nd 2 digits make up the eyes, 11 variations:
    eyeChoice: skillStr.substring(2, 4) % 11 + 1,
    // 6 variations of shirts:
    shirtChoice: skillStr.substring(4, 6) % 6 + 1,
    // last 6 digits control color. Updated using CSS filter: hue-rotate
    // which has 360 degrees:
    skinColorChoice: parseInt(skillStr.substring(6, 8) / 100 * 360),
    eyeColorChoice: parseInt(skillStr.substring(8, 10) / 100 * 360),
    clothesColorChoice: parseInt(skillStr.substring(10, 12) / 100 * 360),
    roleName: name,
    roleDescription: "A Level 1 CryptoRole",
  }
  return rolesDetails
}
